{"version":3,"sources":["vue-notifications.es5.js"],"names":["root","factory","define","amd","exports","module","VueNotifications","this","PLUGIN_NAME","PROPERTY_NAME","TYPE","error","warn","info","success","MESSAGES","alreadyInstalled","methodNameConflict","type","propertyName","config","timeout","installed","show","dismiss","install","Vue","arguments","length","undefined","console","window","use"],"mappings":"CAAE,SAASA,EAAMC,GACO,kBAAXC,SAAyBA,OAAOC,IACzCD,UAAWD,GACiB,gBAAZG,SAChBC,OAAOD,QAAUH,IAEjBD,EAAKM,iBAAmBL,KAE1BM,KAAM,WACR,YAEA,IAAIC,GAAc,mBAEdC,EAAgB,KAEhBC,GACFC,MAAO,QACPC,KAAM,OACNC,KAAM,OACNC,QAAS,WAcPC,GACFC,iBAAkBR,EAAc,6BAChCS,mBAAoBT,EAAc,uBA0IhCF,GACFY,KAAMR,EACNS,aAAcV,EACdW,QACEF,KAAMR,EAAKG,KACXQ,QAAS,KAEXC,WAAW,EACXC,KAAM,SAAcH,KAMpBI,QAAS,aAGTC,QAAS,SAAiBC,GACJC,UAAUC,OAAS,GAAsBC,SAAjBF,UAAU,GAAmBA,UAAU,KAEnF,IAAIpB,KAAKe,UAAW,KAAMQ,SAAQnB,MAAMI,EAASC,iBAMjDT,MAAKe,WAAY,GAOrB,OAHsB,mBAAXS,SAA0BA,OAAOL,KAC1CK,OAAOL,IAAIM,IAAI1B,GAEVA","file":"vue-notifications.es5.min.js","sourcesContent":[";(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.VueNotifications = factory();\n  }\n}(this, function() {\n'use strict';\n\nvar PLUGIN_NAME = 'VueNotifications';\n// const PACKAGE_NAME = 'vue-notifications'\nvar PROPERTY_NAME = '$n';\n\nvar TYPE = {\n  error: 'error',\n  warn: 'warn',\n  info: 'info',\n  success: 'success'\n};\n\n// const VUE_VERSION = {\n//   1: {\n//     init: 'init',\n//     destroy: 'beforeDestroy'\n//   },\n//   2: {\n//     init: 'beforeCreate',\n//     destroy: 'beforeDestroy'\n//   },\n// }\n\nvar MESSAGES = {\n  alreadyInstalled: PLUGIN_NAME + ': plugin already installed',\n  methodNameConflict: PLUGIN_NAME + ': names conflict - '\n};\n\n// function getVersion (Vue) {\n//   const version = Vue.version.match(/(\\d+)/g)\n//   return {\n//     major: +version[0],\n//     regular: +version[1],\n//     minor: +version[2]\n//   }\n// }\n\nfunction showInConsole(msg, type, types) {\n  if (type === types.error) console.error(msg);else if (type === types.warn) console.warn(msg);else if (type === types.success) console.info(msg);else console.log(msg);\n}\n\nfunction showDefaultMessage(_ref) {\n  var type = _ref.type,\n      message = _ref.message,\n      title = _ref.title,\n      debugMsg = _ref.debugMsg;\n\n  var msg = 'Title: ' + title + ', Message: ' + message + ', DebugMsg: ' + debugMsg + ', type: ' + type;\n\n  showInConsole(msg, type, TYPE);\n\n  return msg;\n}\n\nfunction getValues(vueApp, config) {\n  var result = {};\n  var keepFnFields = ['cb']; // TODO (S.Panfilov) any field can be a fn now!\n\n  // TODO (S.Panfilov) if {} we have to build object that extend properties from parents\n  // TODO (S.Panfilov) if func - pass function\n  // TODO (S.Panfilov) if string - pass {msg: 'string'} and etend from upper properties\n\n  Object.keys(config).forEach(function (field) {\n    keepFnFields.forEach(function (fnField) {\n      if (field === fnField) {\n        result[field] = config[field].bind(vueApp);\n      } else {\n        result[field] = typeof config[field] === 'function' ? config[field].call(vueApp) : config[field];\n      }\n    });\n  });\n\n  return result;\n}\n\nfunction showMessage(config, options, vueApp) {\n  var valuesObj = getValues(vueApp, config);\n\n  var isMethodOverridden = options && options[valuesObj.type];\n  var method = isMethodOverridden ? options[valuesObj.type] : showDefaultMessage;\n  method(valuesObj, vueApp);\n\n  if (config.cb) return config.cb();\n}\n\n// function addMethods (targetObj, typesObj, options) {\n//   Object.keys(typesObj).forEach(v => {\n//     targetObj[typesObj[v]] = function (config) {\n//       config.type = typesObj[v]\n//       // TODO (S.Panfilov)fix 'vueApp' in param\n//       return showMessage(config, options)\n//     }\n//   })\n// }\n\n// function setMethod (vueApp, name, options, pluginOptions) {\n//   if (!options.methods) options.methods = {}\n//\n//   if (options.methods[name]) {\n//     // TODO (S.Panfilov) not sure - throw error here or just warn\n//     console.error(MESSAGES.methodNameConflict + name)\n//   } else {\n//     options.methods[name] = makeMethod(vueApp, name, options, pluginOptions)\n//   }\n// }\n\n// function makeMethod (vueApp, configName, options, pluginOptions) {\n//   return function (config) {\n//     const newConfig = {}\n//     Object.assign(newConfig, VueNotifications.config)\n//     Object.assign(newConfig, options[VueNotifications.propertyName][configName])\n//     Object.assign(newConfig, config)\n//\n//     return showMessage(newConfig, pluginOptions, vueApp)\n//   }\n// }\n\n// function initVueNotificationPlugin (vueApp, notifications, pluginOptions) {\n//   if (!notifications) return\n//   Object.keys(notifications).forEach(name => {\n//     setMethod(vueApp, name, vueApp.$options, pluginOptions)\n//   })\n//\n//   vueApp.$emit(`${PACKAGE_NAME}-initiated`)\n// }\n\n// function unlinkVueNotificationPlugin (vueApp, notifications) {\n//   if (!notifications) return\n//   const attachedMethods = vueApp.$options.methods\n//   Object.keys(notifications).forEach(name => {\n//     if (attachedMethods[name]) {\n//       attachedMethods[name] = undefined\n//       delete attachedMethods[name]\n//     }\n//   })\n//\n//   vueApp.$emit(`${PACKAGE_NAME}-unlinked`)\n// }\n\n\n// function makeMixin (Vue, pluginOptions) {\n//   const version = getVersion(Vue).major\n//\n//   // TODO (S.Panfilov) this?\n//   // TODO (S.Panfilov) : function () { ?\n//\n//   return {\n//     [VUE_VERSION[version].init]: function () {\n//       const vueApp = this\n//       const vueAppOptions = this.$options\n//       const notificationsField = vueAppOptions[VueNotifications.propertyName]\n//\n//       initVueNotificationPlugin(vueApp, notificationsField, pluginOptions)\n//     },\n//     [VUE_VERSION[version].destroy]: function () {\n//       const vueApp = this\n//       const vueAppOptions = this.$options\n//       const notificationsField = vueAppOptions[VueNotifications.propertyName]\n//       unlinkVueNotificationPlugin(vueApp, notificationsField)\n//     }\n//   }\n// }\n\nvar VueNotifications = {\n  type: TYPE,\n  propertyName: PROPERTY_NAME,\n  config: {\n    type: TYPE.info,\n    timeout: 3000\n  },\n  installed: false,\n  show: function show(config) {\n    // TODO (S.Panfilov) config has to be an Object\n    //example 1: this.$n.show(this.$n.login.success)\n    //example 2: this.$n.show(this.$n.error.login)\n    //example 3: this.$n.show({msg: 'asdasd'})\n  },\n  dismiss: function dismiss() {\n    // TODO (S.Panfilov) required for timeout 0\n  },\n  install: function install(Vue) {\n    var pluginOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.installed) throw console.error(MESSAGES.alreadyInstalled);\n    // const mixin = makeMixin(Vue, pluginOptions)\n    // Vue.mixin(mixin)\n\n    // addMethods(this, this.type, pluginOptions)\n\n    this.installed = true;\n  }\n};\n\nif (typeof window !== 'undefined' && window.Vue) {\n  window.Vue.use(VueNotifications);\n}\nreturn VueNotifications;\n}));\n"]}